#' Fit Bayesian Marginal Additive Model (BMAM) 
#' 
#' modified from \code{brmsmargins::marginalcoef} function. 
#'
#' @param object A fitted brms model object that includes random effects.
#'   Required.
#' @param preddat Predicted data. A data frame containing covariates at which
#'   predictions are required. If empty, it will be generated by
#'   \code{generate_pred()}
#' @param length Number of observations in the generated predicted data.
#' @param summarize A logical value, whether or not to calculate summaries of
#'   the posterior predictions. Defaults to \code{TRUE}.
#' @param posterior A logical value whether or not to save and return the
#'   posterior samples. Defaults to \code{FALSE} as the assumption is a typical
#'   use case is to return the summaries only.
#' @param backtrans A character string indicating the type of back
#'   transformation to be applied. Can be one of \dQuote{response} meaning to
#'   use the response scale, \dQuote{linear} or \dQuote{identity} meaning to use
#'   the linear predictor scale, or a specific back transformation desired, from
#'   a possible list of \dQuote{invlogit}, \dQuote{exp}, \dQuote{square}, or
#'   \dQuote{inverse}. Custom back transformations should only be needed if, for
#'   example, the outcome variable was transformed prior to fitting the model.
#'   default: \dQuote{response}
#' @param centered Whether or not return centered smooths. Default \code{FALSE}
#'   If \code{TRUE}, the smooth predictions returned will have their means
#'   subtracted such that they have mean zero across the supplied covariate
#'   values for predictions. See \code{MAM} package.
#' @param k An integer providing the number of random draws to use for
#'   integrating out the random effects. Only relevant when \code{effects} is
#'   \dQuote{integrateoutRE}.
#' @param ... Additional arguments passed to \code{fitted()}
#' @return Objects of Class 'bmam', a list containing the fitted Bayesian
#'   marginal additive model and the results from the conditional model. Some of
#'   these may be \code{NULL} depending on the arguments used.
#' @references Hedeker, D., du Toit, S. H., Demirtas, H. & Gibbons, R. D. (2018)
#'   \doi{10.1111/biom.12707} \dQuote{A note on marginalization of regression
#'   parameters from mixed models of binary outcomes}
#'
#'   McGee G. & Stringer A. (2018) \dQuote{Flexible Marginal Models for Dependent
#'   Data}
#' @seealso \code{\link{brms}}, \code{\link{brmsmargins}}, \code{\link{mam}}
#' @importFrom data.table as.data.table
#' @importFrom stats formula
#' @importFrom posterior as_draws_df ndraws
#' @importFrom brms make_standata
#' @importFrom methods missingArg
#' @export
bmam <- function(object, preddat, length = 100, summarize = TRUE, posterior = TRUE, 
                 backtrans = c("response", "linear", "identity",
                               "invlogit", "exp", "square", "inverse"),
                 centered = FALSE, k = 100, ...) {
  if (isFALSE(object$backend) == "cmdstanr") {
    stop("We only support cmdstanr. Please change backend of brms to cmdstanr by backend = \"cmdstanr\" ")
  }
  
  ## check smooth term
  smooth <- !is.null(brmsterms(object$formula)$dpars$mu$sm)
  
  ## checks and assertions
  brmsmargins:::.assertbrmsfit(object)

  if (isFALSE(brmsmargins:::is.random(object))) {
    stop("object must have random effects to use marginalcoef()")
  }
  
  ## predicted data
  if (missingArg(preddat)) preddat <- generate_pred(object, length)
    
  ## assert the assumed family / distribution is a supported one
  brmsmargins:::.assertfamily(object)
  ## assert the link function used is a supported one
  brmsmargins:::.assertlink(object)
  ## assert that all random effects in the model are Gaussian
  brmsmargins:::.assertgaussian(object)


  
  # Convert a Link Function Name to a List
  backtrans <- match.arg(backtrans)
  links <- brmsmargins:::.links(
    link = brmsmargins:::.extractlink(object, NULL),
    effects = "integrateoutRE", backtrans = backtrans)
  
  
  
  
  ####### Conditional Model ##############
  
  # CI <- ifelse(is.element("CI", list(...)), CI, 0.99) 
  predict_conditional <- conditional_brms(object, preddat, centered = centered, ...)
  
  
  
  
  ####### Marginal Model #################
  # get the dataset in the model.
  mf <- model.frame(object)
  
  # see prediction function. 
  # get the predictive posterior distribution of \mu 
  mu <- brmsmargins::prediction(
    object, data = mf,
    summarize = FALSE, posterior = TRUE,
    effects = "integrateoutRE", backtrans = backtrans,
    k = k, raw = TRUE)

  # convert \mu to \eta = g(\mu). links$fun: link function
  
  # get lambda_pa in equation 6 in Hedeker's paper
  y <- links$fun(t(mu$Posterior))
  
  ## dim(y) == number of observations * number of draws(in MCMC)
  
  
  # design matrix in dataset
  standata <- make_standata(formula(object), data = mf)
  
  if(smooth){
    data_names <- names(standata) # get the names of data
    
    # ## Z: design matrix for random effect
    # Z_name <- data_names[grep(pattern = "Z_\\d_\\d", data_names)]
    # Z <- do.call(cbind,standata[Z_name])
    
    ## Zs: basis function for smooth term (ncol = k-2)
    Zs_name <- data_names[grep(pattern = "Zs_\\d_\\d", data_names)]
    Zs <- do.call(cbind, standata[Zs_name])
    ## set names for Zs
    Zs_name_list <- mapply(function(i,j)paste(j,seq_len(i),sep="_alpha_"), 
                           lapply(standata[Zs_name],ncol), # number of basis function
                           Zs_name,
                           SIMPLIFY = FALSE)
    colnames(Zs) <- as.character(unlist(Zs_name_list))
    
    
    ## Xs: basis function for smooth term, without penalty (ncol = 1)
    Xs_name <- data_names[grep(pattern = "Xs", data_names)]
    Xs <- do.call(cbind, standata[Xs_name])
    ## set names for Xs
    Xs_name_list <- mapply(function(i,j)paste(j,seq_len(i),"alpha",sep="_"), 
                           lapply(standata[Xs_name],ncol), # number of basis function
                           Xs_name)
    colnames(Xs) <- as.character(unlist(Xs_name_list))
    
    
    ## X: linear term, for example intercept + x1 + x2 + x1:x2
    X <- standata$X
    
    ## design matrix for 
    B <- cbind(X, Xs, Zs)
  }else{
    B <- standata$X # in GLMM, B=X, linear term, for example 1 + x1 + x2 + x1:x2
  }
  

  ## calculate beta_pa using equation 6 in Hedeker's paper
  ## heagerty's method, solve  
  beta <- lmcpp(B, y)  # Cpp file. faster than beta <- solve( t(B) %*% B ) %*% t(B) %*% y
  rownames(beta) <- colnames(B)
  
  
  out <- list(
    Conditional = NULL, # conditional model
    Summary = NULL, # summary of the posterior distribution of parameters 
    Summary_para = NULL, # arguments used in bsummary() for summary results. 
    Posterior = NULL, # samples from posterior distribution
    Preddat = NULL, # predicted data
    DesignMatrix = NULL, # design matrix B
    Bname = NULL, # variable names for B
    # Smooth = NULL, # fitted values
    Predicted = NULL, # estimates of each smooth function under different samples 
    Predicted_Summary = NULL, # summary of estimates of each smooth function under different samples 
    Family = object$family, 
    Formula = object$formula,
    Centered = centered)

  out$Conditional <- list(Brms = object,
                          Predicted = predict_conditional)
                   
  if (isTRUE(summarize)) { # does not work for 
    out$Summary <- as.data.table(do.call(rbind, apply(beta, 1, bsummary, ...)))
    out$Summary[, Label := colnames(B)]
    out$Summary_para <- list(...) # get arguments for bsummary, used in plot function. 
  }

  if(smooth){
    Bname <- mapply(c, as.list(Xs_name_list), Zs_name_list) # variable names for basis function. 
    ## estimate the smooth function by B*\alpha
    if(!is.list(Bname)){ # convert Bname to a list
      Bname <- lapply(seq_len(ncol(Bname)), function(i) Bname[,i])
    }
    
    
    out$DesignMatrix <- B
    out$Bname <- Bname
    
    ## fitted value
    # smooth_estimates <- lapply(Bname, function(name)B[,name] %*% beta[name, ])
    # names(smooth_estimates) <- paste0("f",seq_along(Bname))
    # out$Smooth <- smooth_estimates
    
    
    if(!missingArg(preddat)){


      object <- restructure(object)
      prep <- prepare_predictions(object, newdata = preddat,check_response = FALSE, re_formula = NA)
      
      ## Xs: basis function for smooth term, without penalty (ncol = 1)
      pred_Xs <- prep$dpars$mu$sm$fe$Xs
      
      ## Zs: basis function for smooth term (ncol = k-2)
      pred_Zs <- sapply(prep$dpars$mu$sm$re, function(re.)re.$Zs)
      pred_Zs <- do.call(cbind, pred_Zs)
      
      ## X: linear term, for example intercept + x1 + x2 + x1:x2
      pred_X <- prep$dpars$mu$fe$X
      pred_B <- cbind(pred_X, pred_Xs, pred_Zs)
      
      if(centered) pred_B <- sweep(pred_B,2,colMeans(pred_B),'-') # Return centered smooths.
      
      ## projection 
      ## the same as  sweep(pred_B,2,colMeans(pred_B),'-') 
      # ones <- matrix(rep(1,nrow(pred_B)))
      # H_matrix <- ones %*% solve(t(ones) %*% ones) %*% t(ones)
      # M_matrix <- diag(1,nrow(pred_B)) - H_matrix
      # pred_B <- M_matrix %*% pred_B
      
      Predicted <- pred_B %*% beta
      out$Predicted <- Predicted
      out$Predicted_Summary <- as.data.table(do.call(rbind, apply(Predicted, 1, bsummary, ...)))
    }
    if (isTRUE(posterior)) {
      out$Posterior <- beta
    }
    out$Preddat <- preddat
  }

  structure(out, class = "bmam") # S3 class
  # return(out)
}
